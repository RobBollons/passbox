#!/bin/bash
#
# Script for managing passwords in a symmetrically encrypted file using GnuPG.
#
# Copyright (C) 2015 Robert Bollons - All Rights Reserved
# Permission to copy and modify is granted under the MIT license
# Version 2.0.0
# Licence: MIT

set -o errtrace
set -o nounset
set -o pipefail

gpg=$(which gpg)
passbox=${PASSBOX_LOCATION:=~/pass-test.gpg}
seperator="|"

#######################################
# HELPERS
#######################################

#######################################
# Print an error message and then exit
# Globals:
#
# Arguments:
#   1 = the error message to output
# Returns:
#   The formatted error message
#######################################
fail () {
    echo "Error: ${1}" ;
    exit 1
}

#######################################
# Make sure required programs are installed and can be executed.
# Globals:
#   gpg
# Arguments:
#
# Returns:
#
#######################################
check_deps () {
    if [[ -z ${gpg} && ! -x ${gpg} ]] ; then
      fail "GnuPG is not available"
    fi
}

#######################################
# Searches for an entry based on a given string (can be regex)
# Globals:
#
# Arguments:
#   1 = the string (regex) to search for
# Returns:
#   pass_vals_string = the first line found in the file
#######################################
search () {
    local hasRecords=false
    if [ ! -s "${passbox}" ] ; then
        fail "No passwords found"
    else
        get_pass "Enter password to unlock ${passbox}: " ; echo
            while read -r line; do
                unset pass_vals
                split_line "${line}"
                if [[ ${#pass_vals[@]} -gt 1 ]] ; then
                    echo -e "\nName:     ${pass_vals[0]}\nUsername: ${pass_vals[1]}\nPassword: ${pass_vals[2]}"
                    hasRecords=true
                fi
            done < <(decrypt "${password}" "${passbox}" | grep -i "$1")
        if [ "$hasRecords" == false ]; then
            fail "No entries found"
        fi
    fi
}

#######################################
# Generate a random password using GPG
# Globals:
#
# Arguments:
#
# Returns:
#   A random password of a desired length
#######################################
gen_pass () {
    len=20
    max=100
    read -p "Password length? (default: ${len}, max: ${max}) " length
    if [[ ${length} =~ ^[0-9]+$ ]] ; then
        len=${length}
    fi

    # base64: 4 characters for every 3 bytes
    ${gpg} --gen-random -a 0 "$((max * 3/4))" | cut -c -"${len}"
}

#######################################
# Decrypt the password file with a given password
# Globals:
#   pass_vals_string = A string containing the unformatted password entry
# Arguments:
#   1 = the passphrase used to protect the file
#   2 = the location of the password file
# Returns:
#   the decrypted file contents
#######################################
decrypt () {
    echo "${1}" | ${gpg} \
        --decrypt --armor --batch \
        --passphrase-fd 0 "${2}" 2>/dev/null
}

#######################################
#  Encrypt the file contents
# Globals:
#   pass_vals_string = A string containing the unformatted password entry
# Arguments:
#   1 = the passphrase used to protect the file
#   2 = the location of the password file
#   3 = TODO: Figure out if this is needed
# Returns:
#   the decrypted file contents
#######################################
encrypt () {
  ${gpg} \
      --symmetric --armor --batch --yes \
      --passphrase-fd 3 \
      --output "${2}" "${3}" 3< <(echo "${1}")
}


#######################################
# Prompts for new password details
# Globals:
#
# Arguments:
#   1 (optional) = name of the password entry
#   2 (optional) = username of the password entry
#   3 (optional) = password of the password entry
# Returns:
#   passname = name of the password entry
#   username = username of the password entry
#   userpass = password of the password entry
#######################################
new_details () {
    if [[ $# -gt 0 ]] ; then
        passname="$1"
    else
        read -p "Name: " passname
    fi

    if [[ $# -gt 1 ]] ; then
        read -p "Username (${2}): " username
        if [[ -z "${username}" ]]; then
            username="${2}"
        fi
    else
        read -p "Username: " username
    fi

    read -p "Generate password? (y/n, default: y) " rand_pass
    if [[ "${rand_pass}" =~ ^([nN][oO]|[nN])$ ]]; then
        if [[ $# -gt 1 ]] ; then
            get_pass "Enter password for \"${username}\" (${3}): " ; echo
            if [[ -z ${password} ]] ; then
                userpass="${3}"
            else
                userpass="$password"
            fi
        else
            get_pass "Enter password for \"${username}\": " ; echo
            if [[ -z ${password} ]] ; then
                fail "No password provided"
            else
                userpass="${password}"
            fi
        fi
    else
        userpass=$(gen_pass)
        echo "Password: ${userpass}"
    fi
}

#######################################
# Write to the password file
# Globals:
#   passname = A string to use as the key (name of the entry)
#   username = A string to use as the username
#   userpass = A string to use as the password
#   seperator = the seperator character to use between values
#   passbox = the location of the password file
# Arguments:
#
# Returns:
#
#######################################
write_pass () {
    local gpgpass=$password
    if [ -z "${userpass+x}" ] ; then
        new_entry=""
    else
        new_entry="${passname}${seperator}${username}${seperator}${userpass}"
    fi

    if [ -z "${gpgpass+x}" ]; then
        get_pass "Enter password to unlock ${passbox}: " ; echo
        gpgpass=$password
    fi

    ( if [ -f "${passbox}" ]; then
          decrypt "${password}" "${passbox}" | grep -v -e "^${passname}[${seperator}]" # || return
      fi;
      echo "${new_entry}"
    ) | grep -v -e "^[[:space:]]*$" | encrypt "${gpgpass}" "${passbox}" - # || fail "Write failed"

    echo "Done";
}

#######################################
# Prompts for a password, hiding the contents with stars
# Globals:
#
# Arguments:
#   1 = The string to use when prompting for the password
# Returns:
#   password = The resulting password
#######################################
get_pass () {
    password=''
    prompt="${1}"
    while IFS= read -p "${prompt}" -r -s -n 1 char ; do
        if [[ ${char} == $'\0' ]] ; then
            break
        elif [[ ${char} == $'\177' ]] ; then
            if [[ -z "${password}" ]] ; then
                prompt=""
            else
                prompt=$'\b \b'
                password="${password%?}"
            fi
        else
            prompt="*"
            password+="${char}"
        fi
    done

}

#######################################
# Splits a line based on the given seperator into an array
# Globals:
#   seperator = the character to split the string on
# Arguments:
#   1 = the given string to split
# Returns:
#   pass_vals = an array containing the split values
#######################################
split_line () {
    oldIFS=IFS
    IFS="${seperator}" read -ra pass_vals <<< "$1"
    IFS=$oldIFS
}

#######################################
# OPTION METHODS
#######################################

#######################################
# Display the usage of the script
# Globals:
#
# Arguments:
#
# Returns:
#
#######################################
_usage () {
cat << EOF
usage: $0 [action]

Passbox - command line password manager utility

ACTIONS
   get       <entry name>      Get a particular password entry by it's name
   generate                    Generate a new random password
   new|add                     Prompt to create a new password entry
   search    <search pattern>  Search the password database for a particular string, returns the first match
   update    <entry name>      Update an existing entry in the password database
EOF
}

#######################################
# Search the password database for a given string and output the result
# Globals:
#
# Arguments:
#
# Returns:
#
#######################################
_search () {
    search "$1"
}

#######################################
# Generate a random password
# Globals:
#
# Arguments:
#
# Returns:
#
#######################################
_gen_pass () {
    gen_pass
}

#######################################
# Prompt to create a new entry in the pasword database
# Globals:
#
# Arguments:
#
# Returns:
#
#######################################
_new () {
    new_details &&
        get_pass "Enter password to unlock ${passbox}: " ; echo &&
        write_pass
}

#######################################
# Update an existing entry in the datbase
# Globals:
#
# Arguments:
#   2 = the name of the password entry to update
# Returns:
#
#######################################
_update () {
    local gpgpass=""

    get_pass "Enter password to unlock ${passbox}: " ; echo
    gpgpass=${password}

    details=$(decrypt "${password}" "${passbox}" | grep -i "^$1[${seperator}]")
    split_line "${details}"
    if [[ ${#pass_vals[@]} -gt 1 ]] ; then
        new_details "${pass_vals[0]}" "${pass_vals[1]}" "${pass_vals[2]}" &&
            password=$gpgpass &&
            write_pass
    else
        fail "Could not find a password entry for '${1}'"
    fi
}

#######################################
# Get a single entry from the database based on the entries name
# Globals:
#
# Arguments:
#   2 = the string to search for
# Returns:
#
#######################################
_get () {
    search "^$1[${seperator}]"
    echo
}

#######################################
# Deletes an entry from the database based on the entries name
# Globals:
#
# Arguments:
#   2 = the name of the entry to delete
# Returns:
#
#######################################
_delete () {
    local gpgpass=""


    get_pass "Enter password to unlock ${passbox}: " ; echo
    gpgpass=${password}

    details=$(decrypt "${password}" "${passbox}" | grep -i "^$1[${seperator}]")
    split_line "${details}"

    if [[ ${#pass_vals[@]} == 0 ]] ; then
        fail "Could not find a password entry for '${1}'"
    fi

    passname=${pass_vals[0]} &&
        password=$gpgpass &&
        write_pass
    echo "${passname}"
}

# MAIN
check_deps

if [[ $# == 0 ]] ; then
    _usage
else
    case $1 in
        search)
            if ! [ -n "${2+1}" ] ; then
                fail "Please specify a string to search for"
            fi
            _search "$2"
            ;;
        get)
            if ! [ -n "${2+1}" ] ; then
                fail "Please specify the name of an entry to get"
            fi
            _get "$2"
            ;;
        generate|gen)
            _gen_pass
            ;;
        new)
            _new
            ;;
        update)
            if ! [ -n "${2+1}" ] ; then
                fail "Please specify the name of an entry to update"
            fi
            _update "$2"
            ;;
        delete)
            if ! [ -n "${2+1}" ] ; then
                fail "Please specify the name of an entry to delete"
            fi
            _delete "$2"
            ;;
        --help|help)
            _usage
            ;;
        *)
            _usage
            ;;
    esac
fi
